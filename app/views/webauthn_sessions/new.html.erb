<div style="max-width: 500px; margin: 50px auto; padding: 20px; border: 1px solid #ddd; border-radius: 10px; background-color: #f9f9f9;">
  <h2 style="text-align: center; margin-bottom: 30px;">Sign In with Passkey</h2>

  <p style="text-align: center; color: #666; margin-bottom: 30px;">
    Use your fingerprint, face, or device PIN to sign in securely.
  </p>

  <button id="signin-with-passkey-btn" style="width: 100%; padding: 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1.1em; font-weight: bold; margin-bottom: 20px;">
    Sign In with Passkey
  </button>

  <div style="text-align: center; padding-top: 20px; border-top: 1px solid #ddd;">
    <%= link_to "Sign in with password instead", new_user_session_path %>
    <br>
    <%= link_to "Create an account", new_user_registration_path, style: "display: inline-block; margin-top: 10px;" %>
  </div>
</div>

<script>
document.getElementById('signin-with-passkey-btn').addEventListener('click', async function() {
  try {
    // サーバーからチャレンジを取得
    const optionsResponse = await fetch('/webauthn_session/new.json', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    if (!optionsResponse.ok) {
      throw new Error('Failed to get authentication options');
    }

    const options = await optionsResponse.json();

    // Base64URLエンコードされた文字列をArrayBufferに変換
    options.challenge = base64urlDecode(options.challenge);

    if (options.allowCredentials) {
      options.allowCredentials = options.allowCredentials.map(cred => ({
        ...cred,
        id: base64urlDecode(cred.id)
      }));
    }

    // WebAuthn APIを使用して認証
    // optionsにどのキーを利用するかを特定している
    const assertion = await navigator.credentials.get({ publicKey: options });

    // 認証情報をサーバーに送信
    const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
    const authResponse = await fetch('/webauthn_session', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken
      },
      body: JSON.stringify({
        id: base64urlEncode(assertion.rawId),
        rawId: base64urlEncode(assertion.rawId),
        type: assertion.type,
        response: {
          authenticatorData: base64urlEncode(assertion.response.authenticatorData),
          clientDataJSON: base64urlEncode(assertion.response.clientDataJSON),
          signature: base64urlEncode(assertion.response.signature),
          userHandle: assertion.response.userHandle ? base64urlEncode(assertion.response.userHandle) : null
        }
      })
    });

    const result = await authResponse.json();

    if (result.success) {
      window.location.href = result.redirect_url;
    } else {
      alert('Authentication failed: ' + result.error);
    }
  } catch (error) {
    console.error('Error:', error);
    if (error.name === 'NotAllowedError') {
      alert('Authentication was cancelled or timed out');
    } else {
      alert('Failed to sign in with passkey: ' + error.message);
    }
  }
});

// Base64URL utility functions
function base64urlDecode(base64url) {
  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
  const binString = atob(base64);
  const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0));
  return bytes.buffer;
}

function base64urlEncode(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
</script>
